## RK3568 DRM驱动借鉴指南表格

> **🔔 重要架构说明 - Encoder 与 Connector 的关系**
> 
> 在 DRM 框架中，**Encoder** 和 **Connector** 是成对出现的关键组件：
> - **Encoder（编码器）**：负责信号格式转换（如 DPI → DSI、DPI → HDMI），处理协议层和时序层的工作
> - **Connector（连接器）**：负责物理连接管理，包括热插拔检测（HPD）、EDID读取、显示器能力查询等
> 
> **Rockchip 的实现方式**：将 Encoder 和 Connector 集成在同一个驱动文件中。例如：
> - `dw-mipi-dsi.c` = DSI Encoder + DSI Connector
> - `dw_hdmi-rockchip.c` = HDMI Encoder + HDMI Connector
> - `rockchip_lvds.c` = LVDS Encoder + LVDS Connector
> 
> 这种设计是因为它们关系紧密、功能互补，分离反而会增加复杂度。所以当你看到接口驱动层的文件时，要意识到它们同时实现了两个 DRM 对象。

### 📊 核心框架层（高度可借鉴）

| 文件名 | 作用 | 可借鉴程度 | 借鉴内容 | 不能借鉴的部分 | 说明 |
|--------|------|-----------|----------|---------------|------|
| **rockchip_drm_drv.c/h** | **DRM子系统总控制器**：<br>• 负责注册DRM设备（`/dev/dri/card0`）<br>• 使用Component框架协调VOP、DSI、Panel等子模块<br>• 解析设备树并绑定所有显示硬件组件<br>• 提供用户空间API入口（ioctl接口）<br>• 管理全局资源（如IOMMU、私有数据结构）<br>**类比**：这是显示子系统的"中央调度室"，所有模块都要通过它注册和协作 | ⭐⭐⭐⭐⭐ | • DRM设备注册流程<br>• Component框架使用<br>• 设备树解析方式<br>• 用户空间接口设计 | • Rockchip特定的平台代码<br>• GRF寄存器操作 | **必读！这是整个DRM架构的骨架**<br>理解如何组织显示子系统<br />2400行代码 |
| **rockchip_drm_fb.c/h** | **Framebuffer（帧缓冲）管理器**：<br>• 创建和管理DRM framebuffer对象（应用绘制的画布）<br>• 处理多图层叠加（Primary/Overlay/Cursor层）<br>• 管理像素格式转换（RGB888/ARGB8888/NV12等）<br>• 关联GEM内存对象与framebuffer<br>**类比**：这是"画布管理员"，负责组织多个图层的绘制区域，并告诉硬件在哪里读取像素数据 | ⭐⭐⭐⭐⭐ | • DRM framebuffer对象创建<br>• 多图层管理<br>• 格式转换处理 | 无（通用逻辑） | 完全通用的framebuffer管理逻辑<br />500行代码 |
| **rockchip_drm_gem.c/h** | **图形内存（GEM）分配器**：<br>• 分配显存（通过CMA或DMA API）<br>• 管理GEM对象生命周期（创建/映射/销毁）<br>• 提供用户空间mmap接口（让应用直接写显存）<br>• 与IOMMU协作实现地址转换<br>• 支持DMA-BUF导入导出（与GPU/摄像头共享buffer）<br>**类比**：这是"显存银行"，负责分配/回收内存，并处理CPU/GPU/VOP对内存的访问权限 | ⭐⭐⭐⭐⭐ | • GEM对象创建<br>• 内存分配策略<br>• DMA buffer管理<br>• 与IOMMU的集成 | 无（通用逻辑） | GEM是DRM的标准内存管理，完全可复用<br />1200行代码 |
| **rockchip_drm_fbdev.c/h** | **传统fbdev接口模拟层**：<br>• 为老旧应用提供`/dev/fb0`字符设备<br>• 模拟传统的fbdev API（用于终端tty显示）<br>• 在DRM之上封装fbdev语义<br>• 主要用于内核启动logo和控制台显示<br>**类比**：这是"向后兼容适配器"，让不支持DRM的老程序也能用显示功能 | ⭐⭐⭐⭐ | • fbdev模拟实现<br>• 控制台显示支持 | 无（通用逻辑） | 如果需要支持传统fbdev接口（控制台tty）<br />200行代码 |

---

### 📺 显示控制器层（中度可借鉴-架构参考）

| 文件名 | 作用 | 可借鉴程度 | 借鉴内容 | 不能借鉴的部分 | 说明 |
|--------|------|-----------|----------|---------------|------|
| **rockchip_drm_vop2.c** | **VOP2硬件控制器驱动（DRM中的CRTC角色）**：<br>• 从内存读取framebuffer数据（通过IOMMU）<br>• 实现多图层叠加（Win0/1/2支持不同格式和缩放）<br>• 像素格式转换（RGB/YUV/AFBC压缩格式）<br>• 图层缩放（up/downscaling）<br>• 生成视频时序信号（hsync/vsync/DE/pixclk）<br>• 通过DPI接口输出到DSI/LVDS/RGB<br>• 处理VBlank中断并触发原子提交<br>**核心职责**：这是显示硬件的"画面合成器+时序发生器" | ⭐⭐⭐ | • **CRTC实现架构**<br>• Plane管理逻辑<br>• 时序配置流程<br>• 中断处理框架<br>• 原子操作实现 | • 所有寄存器定义和操作<br>• 硬件特定功能<br>• 时钟配置细节 | **重点参考！** 学习如何实现CRTC抽象<br>但寄存器操作要全部替换<br />6700行代码 |
| **rockchip_vop2_reg.c** | **VOP2硬件寄存器定义文件**：<br>• 定义所有VOP2寄存器的地址和bit位<br>• 组织寄存器为结构化配置数据<br>• 定义不同SoC（RK3566/RK3568）的差异<br>• 包含Win/VP/Post-processor的寄存器映射<br>**作用**：这是硬件操作手册的代码化，每个寄存器位都对应芯片Datasheet | ⭐ | • 寄存器组织方式<br>• 配置结构设计 | • 所有具体寄存器值和地址 | 只参考代码组织方式，内容完全不同<br />1300行代码 |
| **rockchip_drm_vop.c/h** | **VOP1硬件控制器驱动（旧架构）**：<br>• RK3399及更早芯片的显示控制器<br>• 功能与VOP2类似但架构更简单<br>• 支持双路独立显示输出<br>• Win数量和功能较VOP2少<br>**对比**：VOP1是单片机时代，VOP2是多核时代 | ⭐⭐ | • 另一种CRTC实现思路 | • 具体硬件操作 | VOP2是新架构，更值得参考 |
| **rockchip_vop_reg.c/h** | **VOP1寄存器定义文件**：<br>• 类似vop2_reg，但针对旧架构<br>• 寄存器地址和VOP2完全不同 | ⭐ | • 寄存器组织方式 | • 具体寄存器定义 | 同上 |
| **rockchip_drm_vvop.c** | **虚拟VOP驱动（软件模拟的CRTC）**：<br>• 创建虚拟的显示输出通道<br>• 将framebuffer通过网络/编码器传输到远端<br>• 用于远程桌面、录屏、虚拟显示器场景<br>• 没有实际硬件，纯软件实现<br>**场景**：类似虚拟显示器用于无头服务器或远程投屏 | ⭐⭐ | • 虚拟显示设备实现<br>• 远程显示架构 | • Rockchip特定实现 | 如果需要虚拟显示/远程显示功能 |

---

### 🔌 接口驱动层（有选择地借鉴）

| 文件名 | 作用 | 可借鉴程度 | 借鉴内容 | 不能借鉴的部分 | 说明 |
|--------|------|-----------|----------|---------------|------|
| **dw-mipi-dsi.c** | **MIPI DSI Host控制器驱动（包含 Encoder + Connector）**：<br><br>**Encoder 部分**：<br>• 接收VOP输出的DPI像素流（并行RGB888）<br>• 将DPI打包成DSI协议包（LP/HS模式切换）<br>• 支持Video Mode（连续视频流）和Command Mode（逐帧刷新）<br>• 配置Lane数量（1-4根数据线）和时钟频率<br>• 通过PHY发送差分信号给屏幕<br><br>**Connector 部分**：<br>• 创建DSI connector对象并注册到DRM<br>• 向DRM报告连接状态（对于固定连接的LCD，通常返回always-connected）<br>• 实现mipi_dsi_host接口供Panel驱动调用<br>• 发送DCS命令给LCD面板（初始化/亮度调节）<br>• 管理Panel的attach/detach生命周期<br><br>**类比**：Encoder是"协议翻译官"，Connector是"外交联络员" | ⭐⭐⭐⭐ | • **DRM Encoder + Connector实现**<br>• mipi_dsi_host接口实现<br>• Video/Command Mode切换<br>• DCS命令传输逻辑<br>• Panel对接方式 | • DesignWare特定寄存器操作<br>• GRF配置<br>• PHY控制细节 | **如果使用Synopsys IP可高度复用**<br>如果自研DSI，参考架构和协议处理<br />2000行代码 |
| **rockchip_lvds.c** | **LVDS接口驱动（包含 Encoder + Connector）**：<br><br>**Encoder 部分**：<br>• 将DPI并行数据转换为LVDS差分串行信号<br>• 支持单通道/双通道LVDS（18bit/24bit色深）<br>• 配置LVDS时序（DE模式/Sync模式）<br><br>**Connector 部分**：<br>• 创建LVDS connector并向DRM注册<br>• 报告连接状态（LVDS屏通常固定连接）<br>• 从Panel驱动获取显示模式信息<br><br>**应用场景**：工控屏、车载屏、医疗设备显示<br>**特点**：LVDS比DSI简单，没有复杂协议，纯粹是并串转换 | ⭐⭐⭐ | • Encoder + Connector实现模式<br>• LVDS时序配置 | • Rockchip LVDS硬件操作 | 如果大疆芯片有LVDS输出 |
| **rockchip_rgb.c** | **RGB并行接口驱动（包含 Encoder + Connector）**：<br><br>**Encoder 部分**：<br>• 直接输出RGB并行信号（24/18/16根数据线）<br>• 输出HSYNC/VSYNC/DE/PCLK控制信号<br>• 无需协议转换，VOP输出直通到引脚<br><br>**Connector 部分**：<br>• 创建RGB connector<br>• 固定连接状态管理<br>• 从设备树读取Panel时序参数<br><br>**应用场景**：低成本TFT屏（480x272/800x480等）<br>**特点**：最原始的显示接口，无需复杂IP核，成本最低 | ⭐⭐⭐ | • 最简单的Encoder + Connector实现<br>• 并行接口时序 | • 具体硬件操作 | 如果有RGB输出 |
| **dw_hdmi-rockchip.c** | **HDMI接口驱动（包含 Encoder + Connector）**：<br><br>**Encoder 部分**：<br>• 将DPI转换为HDMI/DVI信号<br>• 处理HDCP加密（版权保护）<br>• 音频嵌入（I2S音频打包进HDMI）<br>• 支持多种分辨率和刷新率<br><br>**Connector 部分（重点！）**：<br>• **热插拔检测（HPD）**：监测HDMI线是否插入<br>• **EDID读取**：通过I2C读取显示器支持的分辨率<br>• **连接状态报告**：告知DRM显示器是否在线<br>• **模式过滤**：根据EDID筛选可用的显示模式<br><br>**应用场景**：连接电视、显示器、投影仪<br>**特点**：Connector功能最丰富，需处理动态连接 | ⭐⭐⭐ | • HDMI Encoder + Connector完整实现<br>• 音视频同步处理<br>• HPD和EDID处理 | • DesignWare HDMI特定代码 | 如果大疆芯片有HDMI输出 |
| **inno_hdmi.c/h** | **Innosilicon HDMI驱动（包含 Encoder + Connector）**：<br>• 功能与dw_hdmi类似（信号转换、EDID、HPD）<br>• 针对Innosilicon的HDMI IP核<br>• 寄存器定义和dw_hdmi完全不同<br>• 同样需要处理热插拔和EDID读取 | ⭐⭐ | • 另一种HDMI Encoder + Connector实现参考 | • Inno特定硬件操作 | 参考价值较低，优先看dw_hdmi |
| **analogix_dp-rockchip.c** | **DisplayPort（eDP）接口驱动（包含 Encoder + Connector）**：<br><br>**Encoder 部分**：<br>• 将DPI转换为DP协议（高带宽数字接口）<br>• 支持多流传输MST（菊花链连接多显示器）<br>• 音频传输能力<br><br>**Connector 部分**：<br>• **外接DP**：支持热插拔和EDID读取<br>• **内置eDP**：通常固定连接，读取Panel EDID<br>• AUX通道通信（低速双向控制通道）<br>• 链路训练（Link Training）状态管理<br><br>**应用场景**：笔记本内置屏（eDP）、外接高分辨率显示器<br>**与HDMI区别**：DP更适合高分辨率（4K/8K），eDP省电 | ⭐⭐ | • DP Encoder + Connector实现思路<br>• AUX通道和链路训练 | • Analogix DP特定代码 | 如果有DP输出需求 |
| **cdn-dp-*.c** | **Cadence DP驱动（包含 Encoder + Connector）**：<br>• Cadence的DisplayPort IP核<br>• 支持DP 1.4标准（比Analogix版本新）<br>• 功能与analogix_dp类似但硬件实现不同<br>• 同样包含热插拔、EDID、链路训练等Connector功能 | ⭐⭐ | • 另一种DP Encoder + Connector实现 | • Cadence特定代码 | 同上 |

---

### 🎨 扩展功能层（可选借鉴）

| 文件名 | 作用 | 可借鉴程度 | 借鉴内容 | 不能借鉴的部分 | 说明 |
|--------|------|-----------|----------|---------------|------|
| **rockchip_drm_psr.c/h** | **Panel Self-Refresh（面板自刷新）功能**：<br>• 让LCD面板自己缓存当前画面<br>• 画面静止时关闭VOP和DSI时钟以省电<br>• 画面更新时唤醒VOP重新传输<br>• 类似手机息屏显示（AOD）原理<br>• 需要Panel硬件支持PSR功能<br>**省电效果**：静态画面时功耗可降低50%以上 | ⭐⭐⭐ | • PSR功能架构<br>• 省电模式实现 | • Rockchip特定实现 | 如果需要省电功能 |
| **rockchip_drm_backlight.c/h** | **背光亮度控制管理**：<br>• 对接PWM背光设备（通过PWM子系统）<br>• 实现亮度调节接口（/sys/class/backlight）<br>• 与Panel驱动配合管理背光开关时序<br>• 支持线性/非线性亮度曲线<br>**功能**：用户空间调节亮度时，这个模块负责把0-255的值转换成PWM占空比 | ⭐⭐⭐⭐ | • 背光设备对接<br>• 亮度控制逻辑 | 无（通用） | 背光管理通用逻辑，可直接复用 |
| **rockchip_drm_tve.c/h** | **模拟电视编码器（CVBS/S-Video）**：<br>• 将数字RGB信号转换为模拟视频信号<br>• 支持PAL/NTSC制式<br>• 输出到AV接口（黄色莲花头）<br>• 用于连接老式电视<br>**场景**：复古设备、工控显示、监控系统 | ⭐ | • 模拟视频输出 | • 全部硬件相关 | 除非大疆芯片有模拟输出 |
| **rockchip-mipi-csi-tx.c/h** | **MIPI CSI-2 TX（摄像头发送端）**：<br>• 虽然名字是CSI（Camera Serial Interface）<br>• 但物理层和DSI相同（都是D-PHY）<br>• 用于ISP输出图像数据给外部芯片<br>• 协议层与DSI不同（CSI-2 vs DSI）<br>**参考价值**：如果你要做MIPI发送，可以参考PHY配置部分 | ⭐⭐ | • MIPI TX通用逻辑 | • CSI特定代码 | 虽然是摄像头接口，但MIPI协议类似 |

---

### 🔧 桥接芯片驱动（不直接借鉴）

| 目录/文件 | 作用 | 可借鉴程度 | 说明 |
|-----------|------|-----------|------|
| **rk618/** | RK618桥接芯片驱动 | ⭐ | 除非大疆使用RK618，否则不相关 |
| **rk628/** | RK628桥接芯片驱动 | ⭐ | 同上 |
| **ebc-dev/** | 电子墨水屏驱动 | ⭐ | 除非做电子纸显示，否则不相关 |
| **rk3066_hdmi.c/h** | RK3066特定HDMI | ⭐ | 旧芯片驱动，参考价值低 |

---

## 📋 借鉴优先级和建议

### 🥇 第一优先级（必读，架构参考）

1. **rockchip_drm_drv.c** - DRM框架整体架构（Component框架的使用）
2. **rockchip_drm_vop2.c** - CRTC实现的完整示例（显示控制器驱动核心）
3. **rockchip_drm_gem.c** - 内存管理（GEM对象和DMA buffer）
4. **rockchip_drm_fb.c** - Framebuffer管理（多图层组织）
5. **dw-mipi-dsi.c** - **Encoder + Connector 完整实现**（包含协议转换和连接管理）

**学习重点**：

- Component框架如何使用
- DRM对象（CRTC/Encoder/Connector/Plane）如何创建和注册
- **Encoder和Connector的配合关系**（一个负责信号转换，一个负责连接管理）
- Atomic操作如何实现
- 中断如何处理
- **对于 HDMI/DP 等可热插拔接口，重点学习 Connector 的 HPD 和 EDID 处理**

---

### 🥈 第二优先级（功能实现参考）

1. **rockchip_drm_backlight.c** - 背光控制
2. **rockchip_drm_psr.c** - 省电功能
3. **rockchip_lvds.c** / **rockchip_rgb.c** - 其他接口参考

**学习重点**：
- 各种功能如何集成到DRM
- 电源管理如何实现
- 与Panel驱动如何交互

---

### 🥉 第三优先级（了解即可）

1. 桥接芯片相关驱动
2. 旧版VOP驱动
3. 特殊功能驱动（TVE、EBC等）

---

## 💡 具体借鉴策略

### 对于显示控制器驱动（最核心）：

```
rockchip_drm_vop2.c → 你的 dji_display_controller.c

可借鉴：
✅ 整体架构设计
✅ drm_crtc_funcs的实现思路
✅ Plane管理逻辑
✅ 原子操作(atomic_check/atomic_update)流程
✅ VBlank中断处理
✅ 错误处理机制

必须替换：
❌ 所有寄存器地址和定义
❌ 硬件初始化序列
❌ 时钟配置代码
❌ GRF操作
❌ 平台特定的quirks
```

### 对于DRM主驱动：

```
rockchip_drm_drv.c → 你的 dji_drm_drv.c

可借鉴：
✅ drm_driver结构体定义
✅ component_bind流程
✅ 设备树解析方式
✅ ioctl扩展方法
✅ 调试接口实现

必须替换：
❌ compatible字符串
❌ 平台特定初始化
❌ Rockchip特定属性
```

### 对于DSI驱动：

```
dw-mipi-dsi.c → 你的DSI驱动

情况A - 使用Synopsys IP：
✅ 90%代码可复用
❌ GRF配置需要替换
❌ 平台数据需要修改

情况B - 自研DSI：
✅ 参考架构和流程
✅ mipi_dsi_host接口实现
✅ 命令传输逻辑
❌ 所有寄存器操作
❌ 时序配置细节
```

---

## 🎯 实战建议

### 第一步：理解架构
```bash
# 重点阅读这几个文件，理解DRM整体架构
1. rockchip_drm_drv.c      # DRM设备如何注册
2. rockchip_drm_vop2.c     # CRTC如何实现
3. dw-mipi-dsi.c           # Encoder如何实现
4. rockchip_drm_gem.c      # 内存如何管理
```

### 第二步：搭建框架
```c
// 创建你的驱动框架（参考rockchip_drm_drv.c）
static struct platform_driver dji_drm_platform_driver = {
    .probe = dji_drm_platform_probe,
    .remove = dji_drm_platform_remove,
    .driver = {
        .name = "dji-drm",
        .of_match_table = dji_drm_dt_ids,
    },
};
```

### 第三步：实现CRTC
```c
// 参考rockchip_drm_vop2.c的架构
static const struct drm_crtc_funcs dji_crtc_funcs = {
    .atomic_enable = dji_crtc_atomic_enable,
    .atomic_disable = dji_crtc_atomic_disable,
    // ... 其他回调
};
```

### 第四步：添加Encoder
```c
// 参考dw-mipi-dsi.c的实现
static const struct drm_encoder_helper_funcs dji_encoder_helper_funcs = {
    .enable = dji_encoder_enable,
    .disable = dji_encoder_disable,
    // ... 其他回调
};
```

---

## 🔗 深入理解 Encoder 与 Connector

### Connector 的核心职责

虽然 Rockchip 将 Encoder 和 Connector 写在同一个文件中，但它们在 DRM 框架中是两个独立的对象：

| 对象 | 职责 | 典型功能 | 硬件对应 |
|------|------|----------|----------|
| **Encoder** | 信号格式转换 | • DPI → DSI/HDMI/DP<br>• 协议打包<br>• 时序生成 | DSI Host、HDMI TX、DP TX 控制器 |
| **Connector** | 物理连接管理 | • 热插拔检测（HPD）<br>• EDID读取<br>• 连接状态报告<br>• 模式协商 | HDMI/DP 物理接口、I2C 总线 |

### 不同接口的 Connector 复杂度

| 接口类型 | Connector复杂度 | 原因 | 学习建议 |
|---------|----------------|------|---------|
| **DSI（内置LCD）** | ⭐ 简单 | 固定连接，Panel信息已知，无需检测 | 初学者友好 |
| **RGB/LVDS** | ⭐ 简单 | 同上，固定连接 | 初学者友好 |
| **HDMI** | ⭐⭐⭐⭐ 复杂 | 需要HPD检测、EDID解析、多分辨率支持 | **重点学习！** |
| **DisplayPort** | ⭐⭐⭐⭐⭐ 最复杂 | 除HDMI功能外，还有链路训练、MST多流 | 有HDMI基础后再学 |

### 学习 Connector 的重点文件

如果你的芯片需要支持**可热插拔的外接显示器**（如 HDMI、DP），请重点学习：

```c
// 1. 查看 dw_hdmi-rockchip.c 中的 Connector 实现
static const struct drm_connector_funcs dw_hdmi_connector_funcs = {
    .fill_modes = drm_helper_probe_single_connector_modes,  // 获取所有可用模式
    .detect = dw_hdmi_connector_detect,                      // HPD检测
    .destroy = drm_connector_cleanup,
    // ...
};

// 2. 理解 EDID 读取流程
static int dw_hdmi_connector_get_modes(struct drm_connector *connector) {
    struct edid *edid = drm_get_edid(connector, ddc);  // I2C读取EDID
    drm_connector_update_edid_property(connector, edid);
    return drm_add_edid_modes(connector, edid);  // 解析成DRM模式列表
}
```

### Connector 状态机

```
┌─────────────────────────────────────────────────────────┐
│  用户插入HDMI线                                          │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
       ┌─────────────────┐
       │  HPD中断触发    │
       └────────┬────────┘
                │
                ▼
       ┌─────────────────┐
       │ detect()被调用  │ ◄─── Connector职责开始
       │ 返回connected   │
       └────────┬────────┘
                │
                ▼
       ┌─────────────────┐
       │ get_modes()被调 │
       │ 通过I2C读EDID   │
       │ 解析支持的分辨率 │
       └────────┬────────┘
                │
                ▼
       ┌─────────────────┐
       │ mode_valid()验证│
       │ 硬件是否支持该模式│
       └────────┬────────┘
                │
                ▼
       ┌─────────────────┐
       │ 用户空间选择模式│
       │ (Xorg/Wayland)  │
       └────────┬────────┘
                │
                ▼
       ┌─────────────────┐
       │ Encoder开始工作 │ ◄─── Encoder职责开始
       │ 配置时序和协议  │
       └─────────────────┘
```

---

## ⚠️ 特别注意事项

1. **不要直接复制粘贴寄存器操作**
   - Rockchip的寄存器定义对大疆芯片无效
   - 必须查阅大疆芯片的手册，重新定义

2. **GRF相关代码全部不适用**
   - GRF是Rockchip特有的设计
   - 大疆可能有类似的"全局配置寄存器"，但地址和定义不同

3. **时钟名称和管理方式可能不同**
   - 时钟树的结构是平台特定的
   - 需要根据大疆芯片重新设计

4. **Component框架是通用的**
   - 这个框架是内核提供的，可以完全复用思路

5. **DRM框架接口是标准的**
   - 所有drm_*接口都是通用的
   - 重点是如何用这些接口包装你的硬件

6. **Encoder和Connector可以分离实现**
   - 虽然Rockchip合并在一个文件中，但你可以选择分离
   - 对于简单接口（DSI/RGB），合并更简洁
   - 对于复杂接口（HDMI/DP），分离可能更清晰

---

## 📚 推荐学习路径

1. **第1周**：熟悉DRM框架
   - 阅读 rockchip_drm_drv.c，理解整体架构
   - 阅读 Documentation/gpu/drm-kms.rst

2. **第2周**：学习CRTC实现
   - 详细分析 rockchip_drm_vop2.c
   - 理解原子操作流程

3. **第3周**：学习Encoder实现
   - 分析 dw-mipi-dsi.c
   - 理解如何对接Panel

4. **第4周**：学习内存管理
   - 分析 rockchip_drm_gem.c
   - 理解GEM和DMA buffer

5. **第5周开始**：结合大疆芯片手册，开始实际编码

希望这个表格能帮助你理清楚哪些代码可以借鉴！有任何具体问题随时问我。🚀